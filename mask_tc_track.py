# Function to apply masking beyond a radius threshold WRT to a tracked
#   object, e.g., a TC.
# 
# INPUTS:
#       track_file - file path and name for netCDF file containing track as clon,clat
#           (generated by the program run_tracking.py)
#       rmax - radius limit [degrees lon/lat]
#       var - variable to mask as (time,z,x,y) (note, the order of x,y is arbitrary)
#       lon - array of longitude points as (x,y) [deg]
#       lat - " " latitude points
#       t0, t1 - bounding time indices of var, assuming shorter in time than clon/clat
# 
# RETURNS:
#       returns a masked array of identical shape to var.
# 
# James Ruppert  
# jruppert@ou.edu
# September 2022

from netCDF4 import Dataset
import numpy as np

def mask_tc_track(track_file, rmax, var, lon_tmp, lat, t0, t1):

    # Input dimensions
    nt,nz,nx1,nx2 = var.shape

    # Read TC track
    ncfile = Dataset(track_file)
    clon_tmp = ncfile.variables['clon'][t0:t1] # deg
    clat = ncfile.variables['clat'][t0:t1] # deg
    ncfile.close()
    clon_tmp = np.ma.masked_invalid(clon_tmp, copy=True)

    # Function to account for crossing of the Intl Date Line
    def dateline_lon_shift(lon_in, reverse):
        if reverse == 0:
            lon_offset = np.ma.zeros(lon_in.shape)
            lon_offset[np.where(lon_in < 0)] += 360
        else:
            lon_offset = np.ma.zeros(lon_in.shape)
            lon_offset[np.where(lon_in > 180)] -= 360
        # return lon_in + lon_offset
        return lon_offset

    # Check for crossing Date Line
    if (lon_tmp.min() < 0) and (lon_tmp.max() > 0):
        lon_offset = dateline_lon_shift(lon_tmp, reverse=0)
        clon_offset = dateline_lon_shift(clon_tmp, reverse=0)
    else:
        lon_offset = 0
        clon_offset = 0
    lon = np.ma.copy(lon_tmp) + lon_offset
    clon = np.ma.copy(clon_tmp) + clon_offset

    # Calculate radius from center as array(time,x,y)
    lon3d = np.repeat(lon[np.newaxis,:,:], nt, axis=0)
    lat3d = np.repeat(lat[np.newaxis,:,:], nt, axis=0)
    lon3d -= clon[:,np.newaxis,np.newaxis]
    lat3d -= clat[:,np.newaxis,np.newaxis]
    radius3d = np.sqrt( lon3d**2 + lat3d**2 )
    radius3d = np.ma.masked_invalid(radius3d, copy=True)

    # Add vertical dimension to match shape of var
    radius4d = np.repeat(radius3d[:,np.newaxis,:,:], nz, axis=1)
    radius4d = np.ma.masked_invalid(radius4d, copy=True)

    # Apply mask
    var_mask = np.ma.masked_where(radius4d > rmax, var, copy=True)

    # Mask out domain edges, within 0.5*r_max from boundaries
    edge = 1 # deg
    npts = int(np.rint(edge/(lon[0,1]-lon[0,0])))
    # var_mask.mask[:,:,0:npts,:] = True
    var_mask.mask[:,:,0:npts,:] = True
    var_mask.mask[:,:,:,0:npts] = True
    var_mask.mask[:,:,-npts:,:] = True
    var_mask.mask[:,:,:,-npts:] = True

    return var_mask