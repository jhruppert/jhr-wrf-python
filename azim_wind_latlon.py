# Function to convert wind from (time,lat,lon) to the tangential
#   wind as f(time,z,x,y) based on a TC track.
# 
# INPUTS:
#       track_file - file path and name for netCDF file containing track as clon,clat
#           (generated by the program run_tracking.py)
#       rmax - radius limit [degrees lon/lat]
#       u - zonal wind as (time,x,y) (note, the order of x,y is arbitrary)
#       v - meridional wind " "
#       lon - array of longitude points as (x,y) [deg]
#       lat - " " latitude points
#       t0, t1 - bounding time indices of var, assuming shorter in time than clon/clat
# 
# RETURNS:
#       returns a time series masked array of identical shape to var.
# 
# James Ruppert  
# jruppert@ou.edu  
# September 2022

# from netCDF4 import Dataset
# import numpy as np

from netCDF4 import Dataset
import numpy as np

def azim_wind_latlon(track_file, u, v, lon, lat, t0, t1):

    # Settings
    # rmax = 3 # degrees

    # Input dimensions
    nt,nz,nx1,nx2 = u.shape

    # Read TC track
    ncfile = Dataset(track_file)
    clon = ncfile.variables['clon'][:] # deg
    clat = ncfile.variables['clat'][:] # deg
    ncfile.close()

    # Center grid on track
    lon4d = np.repeat(lon[np.newaxis,np.newaxis,:,:], nt, axis=0)
    lat4d = np.repeat(lat[np.newaxis,np.newaxis,:,:], nt, axis=0)
    lon4d -= clon[t0:t1,np.newaxis,np.newaxis,np.newaxis]
    lat4d -= clat[t0:t1,np.newaxis,np.newaxis,np.newaxis]

    # Get radius and azimuth
    radius4d = np.sqrt( lon4d**2 + lat4d**2 )
    azim = np.arctan(lat4d/lon4d)
    azim[(lon4d < 0 )] += np.pi

    # Subtract storm motion
    deg2x = 6371e3*np.pi/180 # m / deg
    # Assume hourly time steps
    dt = 3600. # s/time step
    mpsec = deg2x/dt # m / deg / (s / time step)
    u_track = np.gradient(clon,m=1) * np.cos(clat*np.pi/180) * mpsec # deg / time step --> m / s
    v_track = np.gradient(clat,m=1) * mpsec # deg / time step --> m / s
    print('U = ',u_track)
    print('V = ',v_track)

    # Get tangential wind
    vtx = (u - u_track[:,np.newaxis,np.newaxis,np.newaxis]) * np.sin(azim)
    vty = (v - v_track[:,np.newaxis,np.newaxis,np.newaxis]) * np.cos(azim)
    v_tan = vty - vtx

    return v_tan